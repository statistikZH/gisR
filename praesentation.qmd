---
title: "gisR"
format: revealjs
editor: visual
---

## Was ist R

[R](https://www.r-project.org) ist eine offene Programmiersprache welche ursprünglich für statistische Zwecke erstellt wurde.

Der Einsatzbereich von R hat sich heutzutage weit über die statistischen Anwendungen etabliert.


::: {.callout-note}
Gerade für Data-Wrangling und Data-Engineering kommt die Stärke von R besonders zu tragen.
:::


## GIS mit R

Seit einiger Zeit hat sich R im Bereich GIS weiterentwickelt.
Es lässt sich nun sehr einfach GIS-Prozesse mit Datenanalyse verbinden und es ist kein Medienbruch mehr nötig.

Packages (gleich wie libraries in python)
  - [sf](https://r-spatial.github.io/sf/): Arbeiten mit Feature Classes
  - [terra](https://rspatial.github.io/terra/): Arbeiten mit Raster-Daten
  - [stars](https://r-spatial.github.io/stars/articles/stars1.html): Arbeiten mit Spatio-Temporal Arrays
  
Bücher

  [Spatial Data Science](https://r-spatial.org/book/)



## Einlsesen der Daten


```{r}

# Lesen der Gebäudedaten
gwr <- read.csv("https://www.web.statistik.zh.ch/ogd/daten/ressourcen/KTZH_00002022_00004064.csv")

# gwr <- readRDS("gwr.RDS")
# 
# saveRDS(gwr, file = "gwr.RDS")

# Umwandeln in ein sf-Objekt -> Geodatenobjekt
gwr_sf <- sf::st_as_sf(gwr, coords = c("E.Gebaeudekoordinate", "N.Gebaeudekoordinate"), crs = 2056)

# interaktives Darstellen
mapview::mapview(head(gwr_sf, 20))

gemeinden <- sf::st_read("https://maps.zh.ch/wfs/OGDZHWFS?SERVICE=WFS&VERSION=2.0.0&Request=getfeature&TYPENAME=ms:ogd-0095_arv_basis_up_gemeinden_seen_f&outputformat=geojson")

# Lesen des Gemeindelayers
#gemeinden <- sf::read_sf("Gemeindegrenzen_-OGD.gpkg", layer = "UP_GEMEINDEN_F")


```


## Analysieren der Daten

```{r}


# Matchen der Gemeindeinformation an die GWR-Daten
# Die geometrie wird hier entfernt, da die Datenanalyse danach viel schneller läuft
gwr_sf_gem <- gwr_sf %>% 
  dplyr::select(Gebaeudekategorie_Code, Gebaeudekategorie_Bezeichnung) %>% 
  sf::st_join(gemeinden) %>% 
  sf::st_drop_geometry()


# Berechnung der Anteile der Geböude ohne Wohnnutzung am gesamten Gebäudebestand einer Gemeinde
geb_ohne_wohnnutzung_pro_gem <- gwr_sf_gem %>% 
  dplyr::group_by(Gebaeudekategorie_Code, Gebaeudekategorie_Bezeichnung, BFS, GEMEINDENAME) %>% 
  dplyr::summarise(anzahl = n()) %>% 
  dplyr::ungroup() %>% 
  dplyr::group_by(BFS, GEMEINDENAME) %>% 
  dplyr::mutate(anteil = round(anzahl/sum(anzahl)*100, 2)) %>% 
  dplyr::ungroup() %>% 
  dplyr::filter(Gebaeudekategorie_Code == 1060)




```

## Darstellen der Daten

```{r}
# Hinzufügen der Gemeindepolygone
# Herausfiltern der Seen und fixen der Polygone
geb_ohne_wohnutzung_sf <- gemeinden %>% 
  dplyr::select(BFS) %>% 
  dplyr::left_join(geb_ohne_wohnnutzung_pro_gem, by = "BFS") %>% 
  dplyr::filter(BFS != 0) %>% 
  sf::st_make_valid() %>% 
  # tmap vewendet die erste Spalte als Bezeichner, deshalb hier die Änderung in der Spaltenanordnung
  dplyr::select(GEMEINDENAME, dplyr::everything())


geb_ohne_wohnnutzung_sf_generalized <- geb_ohne_wohnutzung_sf %>% 
  rmapshaper::ms_simplify(keep = 0.005)

# Setzt tmap auf interaktiv
tmap::tmap_mode("view")

# Darstellen der Choropletenkarte
tmap::tm_shape(geb_ohne_wohnnutzung_sf_generalized) +
    tmap::tm_polygons("anteil")

```

